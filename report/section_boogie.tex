\section{Boogie}\label{boogie_discussion}

In this part we discuss the second part of the project, implementing and verifying quicksort and bucketsort 
in Boogie. First we describe how we chose to specify our algorithms e\.g\. how we described the complete behaviour
of our sorting algorithms. Then we quickly discuss how the two algorithms were implemented followed by an in-depth 
discussion about the verification task where we describe the varous problems we faced and how we overcame them. Finally
we compare the task of verifying and specifying in Boogie in contrast to Autoproof.

\subsection{Algorithm Specification}

Both quicksort and bucketsort basically share the same specification aside from some minor differences due to 
implementation details. Therefore we just state the specification of a general sorting algorithm in Boogie which 
applies to both quicksort and bucketsort.\\

The signature of our sort procedure looks as follows:

\begin{verbatim}
  procedure xSort(lo: int, hi: int) returns (perm: [int]int)  
    modifies a;
   ...
 \end{verbatim}

The sort procedure sorts a global variable \texttt{a:[int]int} from indices \texttt{lo} to \texttt{hi}.
This global variable is a map which models a one-dimensional array of integers. We decided from the beginning 
to sort an arbitrary sub-sequence of the array because it would be useful when implementing quicksort.
The return value of \texttt{xSort} is map from \texttt{int} to \texttt{int} which is a permutation on the
array indices that describes how the elements of the array were swapped by \texttt{xSort}.
\\

\texttt{sort} has only one precondition, namely that the input range must not be negative:
\begin{verbatim}
  requires lo <= hi;
\end{verbatim}

To specify the entire behaviour of the sort procedure, we state the following postconditions.
\begin{itemize}
\item After the procedure call, the array must be sorted:
  \begin{verbatim}
  ensures (forall k, l: int :: 
    lo <= k && k <= l && l <= hi ==> a[k] <= a[l]
  );
\end{verbatim}

\item The return value must be a valid permutation of the array indices.
  \begin{verbatim}
  ensures (
    forall i: int :: 
      lo <= i && i <= hi 
      ==> lo <= perm[i] && perm[i] <= hi
  );
  ensures (
    forall k, l: int :: 
      lo <= k && k < l && l <= hi 
      ==> perm[k] != perm[l]
  );
\end{verbatim}

\item The final array is a permutation of the input array. Exactly the permuatation that is returned. 
  \begin{verbatim}
  ensures (
    forall i: int :: 
      lo <= i && i <= hi 
      ==> a_qs[i] == old(a_qs)[perm[i]]
  );
\end{verbatim}
 
\end{itemize}

This specification is influenced by the bubblesort example that is 
given on the Boogie webpage \footnote{\url{http://rise4fun.com/Boogie/Bubble}}. We decided to 
copy the approach of using a concrete permutation to state that the final array is a permutation of
the input array, because we felt that it would be easier to actually construct such a permutation rather
than having to prove just the existance.

\subsection{Quicksort Implementation}

We implemented the textbook definition of quicksort as described in "Introduction to Algorithms". 
Quicksort is implemented by the \texttt{qs} procedure. 
It first partitions the array into a left and right part such that the left part is smaller than or equal to
the pivot and the right part is greater than the pivot. The pivot element is always the right most
element of the array. This partition step is implemented in a separate procedure called \texttt{qsPartition}.
After partitioning, \texttt{qs} is called recursively on the left and the right part of the array. 
In addition to the actual sorting, \texttt{qs} and \texttt{qsPartition} both construct a permutation that
keeps track on how the array elements were swapped. A big part of the implementation consists of code that
combines the permutations returned by \texttt{qsPartition} and the two recursive calls to \texttt{qs} to a single permutation
capturing all swap opperations.

\subsection{Bucketsort Implementation}

Bucketsort is implemented in the \texttt{bucketSort} procedure.  
The procedure divides the array into three buckets with elements in the range of $[-3*N)$, $[-N,N)$ and
$[N,3*N)$ respectively. This is possible because we know that the procedure will only be called with elements in that range.
The three buckets are then all sorted individually with quicksort. 
After that, the now sorted buckets are then copied back into the original array.
\\\\
Just as in quicksort, the bucketsort implementation also has to construct a permutation that reflects
the different swap operations. This was more challenging than in quicksort, because the size of the
three buckets is not known in advance. 


Note that being able to call quicksort with three buckets was not a trivial task. 
The problems are discussed in the next section. 

\subsection{Implementing modular sorting algorithm}

In Boogie, as opposed to Eiffel/Autoproof, it isn't possible for procedures to modify
arguments. This is why our sorting algorithm implementations both sort a global variable. 
In the case of bucketsort however it's necessary to sort three different arrays with the
same procedure e\.g\. quicksort. To solve this issue, we first modified our quicksort implementation
to work on a different global variable \texttt{a\_qs} and then added the following procedure:

\begin{verbatim}
procedure quickSort(arr : [int]int, lo : int, hi : int) 
  returns (arr_sorted : [int]int, perm: [int]int) 
  ...
{
  a_qs := arr;
  call perm := qs(lo,hi);
  arr_sorted := a_qs;
}
\end{verbatim}

The new \texttt{quickSort} has the same specification as \texttt{qs} but instead of sorting a global array,
it takes an array as argument and returns a sorted copy. This is achieved by using \texttt{a\_qs} as temporary 
variable to store the input array. Now with this construction it is possible to sort arbitrary arrays using
our existing quicksort implementation.



\subsection{Verification}

\subsection{Verification}
TODO: report "significant problems" (e.g. which procedures could be verified, and which could not\\
TODO: describe changes to implementation/specification made to simplify proofs\\
TODO: describe which parts of the specification you could not verify and why\\
TODO: explain how you achieved modular verification

\subsection{Boogie vs. Autoproof}
